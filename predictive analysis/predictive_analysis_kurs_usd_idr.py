# -*- coding: utf-8 -*-
"""Predictive_Analysis_Kurs_USD_IDR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E2kE3YUe4_a_jmqmibKFcJsXQOzmotmC
"""

import numpy as np
import pandas as pd
from keras.layers import Dense, LSTM
import matplotlib.pyplot as plt
import tensorflow as tf
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import StandardScaler

data= pd.read_csv('/content/IDR=X.csv')
data.head()

data.info()

data.isnull().sum()

data.dropna(inplace=True)

data.isnull().sum()

data.describe()

jumlah_sampel = data.shape[0]

print("Jumlah sampel dalam dataset:", jumlah_sampel)

import seaborn as sns
import matplotlib.pyplot as plt

# Visualisasi boxplot untuk kolom tertentu
sns.boxplot(x=data['Close'])
plt.show()

data.hist(bins=50, figsize=(20,15))
plt.show()

# Mengamati hubungan antar fitur numerik dengan fungsi pairplot()
sns.pairplot(data, diag_kind = 'kde')

plt.figure(figsize=(10, 8))
correlation_matrix = data.corr().round(2)

# Untuk menge-print nilai di dalam kotak, gunakan parameter anot=True
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

dates = data['Date'].values
close  = data['Close'].values


plt.figure(figsize=(15,5))
plt.plot(dates, close)
plt.title('Close Average',
          fontsize=20);

scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data[['Close']])

scaled_data

# Split data menjadi training dan validation set
train_data, val_data = train_test_split(scaled_data, test_size=0.2, shuffle=False)

def create_dataset(data, time_steps):
    X, y = [], []
    for i in range(len(data) - time_steps):
        X.append(data[i:(i + time_steps)])
        y.append(data[i + time_steps])
    return np.array(X), np.array(y)

time_steps = 30

X_train, y_train = create_dataset(train_data, time_steps)
X_val, y_val = create_dataset(val_data, time_steps)

model = tf.keras.models.Sequential([
  tf.keras.layers.LSTM(60, return_sequences=True),
  tf.keras.layers.LSTM(60),
  tf.keras.layers.Dense(30, activation="relu"),
  tf.keras.layers.Dense(10, activation="relu"),
  tf.keras.layers.Dense(1),
])

from tensorflow.keras.callbacks import EarlyStopping

optimizer = tf.keras.optimizers.SGD(lr=1.0000e-04, momentum=0.9)
model.compile(loss=tf.keras.losses.Huber(),
              optimizer=optimizer,
              metrics=["mae"])

early_stopping = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

# Melatih model
history = model.fit(X_train, y_train, epochs=100, batch_size=32, validation_data=(X_val, y_val), callbacks=[early_stopping])

# Plot loss dan akurasi
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

# Invers scaling untuk mendapatkan harga aktual dan prediksi yang sebenarnya
actual_prices = scaler.inverse_transform(y_val.reshape(-1, 1))
predicted_prices = scaler.inverse_transform(predictions)

# Plot harga aktual dan harga prediksi
plt.figure(figsize=(15, 6))
plt.plot(actual_prices, label='Actual Price', color='blue')
plt.plot(predicted_prices, label='Predicted Price', color='red')
plt.title('Actual vs Predicted Prices', fontsize=16)
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.show()

# Prediksi menggunakan model
predictions = model.predict(X_val)

# Menghitung MAE
mae = np.mean(np.abs(predictions - y_val))
print("Mean Absolute Error:", mae)

# Menghitung threshold untuk MAE < 10% skala data
threshold_mae = (scaled_data.max() - scaled_data.min()) * 10/100
print("Threshold MAE:", threshold_mae)

from datetime import datetime, timedelta

# Meminta pengguna untuk memasukkan tanggal
input_date = input("Masukkan tanggal (format: YYYY-MM-DD): ")

# Ubah input tanggal menjadi objek datetime
input_date = datetime.strptime(input_date, '%Y-%m-%d')

# Ambil data terakhir dalam dataset
last_date = datetime.strptime(data['Date'].iloc[-1], '%Y-%m-%d')

# Jika tanggal yang dimasukkan lebih besar dari tanggal terakhir dalam dataset, gunakan data terakhir yang tersedia
if input_date > last_date:
    print("Tanggal yang dimasukkan lebih besar dari tanggal terakhir dalam dataset.")
    input_date = last_date

# Ambil sejumlah data terakhir sebelum tanggal yang dimasukkan pengguna
input_index = data[data['Date'] == input_date.strftime('%Y-%m-%d')].index[0]
input_data = scaled_data[input_index - time_steps + 1:input_index + 1]

# Bentuk dataset untuk prediksi
X_prediction = np.array([input_data])

# Lakukan prediksi menggunakan model
predicted_price = model.predict(X_prediction)

# Ubah hasil prediksi ke dalam skala semula
predicted_price = scaler.inverse_transform(predicted_price)

# Tampilkan hasil prediksi
print("Prediksi harga untuk tanggal", input_date.strftime('%Y-%m-%d'), "adalah:", predicted_price[0][0])